#!/usr/bin/env perl

# this file is licensed under the General Public License (GPL) version 3

sub STRACE (){ 0 }
sub PRCPU  (){ 0 }
sub PRIPS  (){ 0 }
sub PRDIFF (){ 0 }
sub DETSYS (){ 0 }  # Make some system calls deterministic.

use strict;

BEGIN {
   eval { require warnings };  # Perl 5.004_04 doesn't have it.
   import warnings;
   if (defined(&warnings::import)) {
      import warnings;
      # Most of $mem[$i] is undef by design, a 0 value is assumed.
      #
      # Perl still reports a warning if we read vec($mem[$page_idx], ..., 32)
      # if the page is undef. We don't want to see those warnings.
      #
      # Perl 5.6.0 and later report fewer uninitialized warnings than Perl
      # 5.004_04, but it's still not completely silent.
      unimport warnings qw(uninitialized);
   }
   # We could do `BEGIN { $^W = 0 }' in Perl 5.004_04, but there is no fast way
   # to selectively disable the /^Use of uninitialized value at / warnings.
}

#use features qw(...);  # None needed.

BEGIN {  # Perl 5.004_04 doesn't have `no utf8;', so we do it leniently.
   eval { require utf8 };
   unimport utf8 if defined(&utf8::unimport);
}

# genfh is a helper function for filehandle symbol generation.
#sub genfh;  # No prototype, can't predict prototype of \&Symbol::gensym.
sub my_open($$);
sub my_sysopen($$$$);
sub my_opendir($$);
BEGIN {
   if ($] >= 5.006) {
      *::genfh = sub {};
      *::my_open = sub ($$) { open($_[0], $_[1]) };
      *::my_sysopen = sub ($$$$) { sysopen($_[0], $_[1], $_[2], $_[3]) };
      *::my_opendir = sub ($$) { opendir($_[0], $_[1]) };
   } else {
      eval { require Symbol };
      die "Symbol::gensym not found" if !defined(&Symbol::gensym);
      *::genfh = \&Symbol::gensym;
      my $fhsym;
      *::my_open = sub ($$) {
         open($_[0], $_[1]) if defined($_[0]);
         $fhsym = genfh() if !defined($fhsym);
         my $result = open($fhsym, $_[1]);
         $_[0] = $fhsym, $fhsym = undef if $result;
         $result
      };
      *::my_sysopen = sub ($$$$) {
         sysopen($_[0], $_[1], $_[2], $_[3]) if defined($_[0]);
         $fhsym = genfh() if !defined($fhsym);
         my $result = sysopen($fhsym, $_[1], $_[2], $_[3]);
         $_[0] = $fhsym, $fhsym = undef if $result;
         $result
      };
      *::my_opendir = sub ($$) {
         opendir($_[0], $_[1]) if defined($_[0]);
         $fhsym = genfh() if !defined($fhsym);
         my $result = opendir($fhsym, $_[1]);
         $_[0] = $fhsym, $fhsym = undef if $result;
         $result
      };
   }
}

BEGIN {
   eval { require Time::HiRes };
   # Debian woody doesn't have `apt-get install libtime-hires-perl' by default,
   # provide a fallback which lacks millisecond precision.
   *Time::HiRes::gettimeofday = sub { time(), 0 } if
       !defined(&Time::HiRes::gettimeofday);
   *Time::HiRes::time = sub { time } if !defined(&Time::HiRes::time);
}
use POSIX ();
use Cwd ();
use Fcntl ();

my $use_int32;
BEGIN {
   require integer;
   # Detection works with `use integer' and `no integer'.
   if (((2 ** 31) ** 2 | 0) / 2 ** 31 >= 2 ** 30) {
      if ($ENV{FORCE_INT32}) {
        unimport integer; $use_int32 = 1;  # Works.
      } else {
        import integer;  $use_int32 = 0;  # Works.
      }
   } elsif (((2 ** 15) ** 2 | 0) / 2 ** 15 >= 2 ** 14) {
      unimport integer;  $use_int32 = 1;  # Works.
   } else {
      die "Perl with at least 32-bit integers needed";
   }
}

# TODO(pts): Take a closer look at what integer operations can fail.
# !! `no integer' 32-bit Perl weirdness on i386:
#    (4294967296 & 4294967295) == 4294967295, should be 0
#    (42 << 32) == 42, should be 42 * 4294967296
#    (5 << 31) == 2147483648, should be 5 * 2147483648
#    good: (1 << 31 >> 31) == 1
# !! `use integer' 64-bit Perl weirdness:
#    (1 << 63 >> 63) == -1

# TODO(pts): Use $SIG{...} to propagate signals. Can we invoke the signal
#            handler any time?

#############################################################################
# system state


sub ADDR_SHIFT(){         16 }
sub ADDR2_SHIFT(){        14 }
sub ADDR_MASK (){     0x3fff }
sub ADDR4_MASK(){     0xffff }

sub STACK     (){ 0xf00f0000 }
sub MINBRK    (){ 0x10000000 }

sub M32       (){ 0xffffffff }
sub B31       (){ 0x80000000 }
sub M16       (){     0xffff }
sub B15       (){     0x8000 }
sub M8        (){       0xff }
sub B7        (){       0x80 }

my $mask_mode;
# !! TODO(pts): Make it faster for !$use_int32.
# $_[0] can be any number between -2**53 and 2**53. The return value is
# between 0 and 4294967295.
sub mask32($);
# Shift left.
# !! TODO(pts): Make it faster for !$use_int32.
# !! TODO(pts): Make it faster for $use_int32 (and with mask, then shift).
sub shl($$);
BEGIN {
   if ((4294968000 | 0) == 704) {
      $mask_mode = 0;
      # Fast solution to truncate to unsigned 32 bits in Perl 5.004_04. Also
      # `$_[0] % 4294967296' doesn't work, it's equivalent to `$_[0] % 0'.
      *::mask32 = sub ($) { $_[0] | 0 };
      # !! TODO(pts): Make it faster.
      *::shl = sub ($$) { ($_[0] * (2 ** $_[1])) | 0 };
   } elsif ($use_int32) {
      $mask_mode = 1;
      *::mask32 = sub ($) { $_[0] % 4294967296 };
      # !! TODO(pts): Make it faster.
      *::shl = sub ($$) { ($_[0] * (2 ** $_[1])) % 4294967296 };
   } else {
      $mask_mode = 2;
      *::mask32 = sub ($) { $_[0] & M32 };
      *::shl = sub ($$) { ($_[0] << $_[1]) & M32 };
   }
   # !! TODO(pts): Double check that ~ (bitwise not) works correctly.
}

my $loadi_or0;
BEGIN {
   # We need to test for -1.0, because in Perl 5.6.1: 4294967295 == -1, even
   # if `no integer' is active.
   if (vec("\xff\xff\xff\xff", 0, 32) == -1.0) {
      # vec returns a nonnegative 32-bit integer, except that in Perl 5.004_04
      # it can return negative values. We'll use `| 0' to fix it.
      die "unsupported vec and or behavior" if
          (4294968000 | 0) != 704 or (-1 | 0) != 4294967295;
      $loadi_or0 = " | 0";
   } else {
      # " | 0" also works here, but it is slower.
      $loadi_or0 = "";
   }
}

my @mem; # [16bits][14bits] = 32bits

sub memset($$) {
   die "memset too early" if $_[0] < 0;
   my $end = $_[0] + length($_[1]);
   die "memset too long" if $end > 4294967296;

   for (my $i = $_[0]; $i < $end;) {
      my $j = $i >= 4294901760 ? $end : ($i + 65536) & ~65535;
      $j = $end if $j > $end;
      my $ia = $i >> ADDR_SHIFT;
      my $im = $i & ADDR4_MASK;
      $mem[$ia] = "" if !defined($mem[$ia]);
      $mem[$ia] .= "\0" x ($im - length($mem[$ia]));
      substr($mem[$ia], $im, $j - $i) = substr($_[1], $i - $_[0], $j - $i);
      $i = $j;
   }
}

sub memget($$) {
   die "memget too early" if $_[0] < 0 or $_[1] < 0;
   my $end = $_[0] + $_[1];
   die "memget too long" if $end > 4294967296;
   my $r = "";
   # TODO(pts): Replace vec in memget and memstr with substr for speed.
   for (my $i = $_[0]; $i < $end; ++$i) {
      vec($r, $i - $_[0], 8) = vec($mem[$i >> ADDR_SHIFT], $i & ADDR4_MASK, 8);
   }

   $r
}

sub memstr($) {
   die "memstr too early" if $_[0] < 0;
   die "memstr too long" if $_[0] > 4294967295;
   my $r = "";

   for (my $i = $_[0]; ; ++$i) {
      die "memstr too long" if $i > 4294967295;
      vec($r, $i - $_[0], 8) = vec($mem[$i >> ADDR_SHIFT], $i & ADDR4_MASK, 8)
          || last;
   }

   $r
}

sub mem_reset() {
   @mem = ();
}

############################################

my ($pc, $hi, $lo, $delay,  # cpu state
    $r0 , $r1 , $r2 , $r3 , $r4 , $r5 , $r6 , $r7 ,
    $r8 , $r9 , $r10, $r11, $r12, $r13, $r14, $r15,
    $r16, $r17, $r18, $r19, $r20, $r21, $r22, $r23,
    $r24, $r25, $r26, $r27, $r28, $r29, $r30, $r31);

my %insn2src; # insn to perl source
$insn2src{0} = '#nop';
my %insn2sub; # insn to compiled perl sub
# Shortcut for nop. It would work without it, nop is equivalent to:
# sll $r0 $r0 0.
$insn2sub{0} = sub {};

# Print CPU state just before exectuing the instruction $delay.
sub cpu_pr() {
   printf " 0 %8x=zr %8x=at %8x=v0 %8x=v1 %8x=a0 %8x=a1 %8x=a2 %8x=a3\n", $r0 , $r1 , $r2 , $r3 , $r4 , $r5 , $r6 , $r7;
   printf " 8 %8x=t0 %8x=t1 %8x=t2 %8x=t3 %8x=t4 %8x=t5 %8x=t6 %8x=t7\n", $r8 , $r9 , $r10, $r11, $r12, $r13, $r14, $r15;
   printf "16 %8x=s0 %8x=s1 %8x=s2 %8x=s3 %8x=s4 %8x=s4 %8x=s6 %8x=s6\n", $r16, $r17, $r18, $r19, $r20, $r21, $r22, $r23;
   printf "24 %8x=t8 %8x=t9 %8x=k0 %8x=k1 %8x=gp %8x=sp %8x=fp %8x=ra\n", $r24, $r25, $r26, $r27, $r28, $r29, $r30, $r31;
   printf "   %8x=pc %8x=lo %8x=hi\n", $pc << 2, $lo, $hi;
   printf "delay=%8x: (%s)\n", $delay, (get_insn($delay) and $insn2src{$delay});
   my $nextinsn = vec($mem[$pc >> (ADDR2_SHIFT)], $pc & ADDR_MASK, 32) | 0;
   printf "nextinsn=%8x: (%s)\n", $nextinsn, (get_insn($nextinsn) and $insn2src{$nextinsn});
}

############################################
# syscalls

# mips abi
sub ENOENT (){  2 }
sub EBADF  (){  9 }
sub ENOMEM (){ 12 }
sub ENOTTY (){ 25 }
sub ERANGE (){ 34 }
sub EAGAIN (){ 35 }
sub ENOTSOCK(){ 88 }
sub ENOSYS (){ 89 }

sub O_ACCMODE   (){    0003 }
sub O_RDONLY    (){      00 }
sub O_WRONLY    (){      01 }
sub O_RDWR      (){      02 }
sub O_APPEND    (){  0x0008 }
sub O_SYNC      (){  0x0010 }
sub O_NONBLOCK  (){  0x0080 }
sub O_CREAT     (){  0x0100 } # not fcntl
sub O_TRUNC     (){  0x0200 } # not fcntl
sub O_EXCL      (){  0x0400 } # not fcntl
sub O_NOCTTY    (){  0x0800 } # not fcntl
sub O_ASYNC     (){  0x1000 }
sub O_NOFOLLOW  (){ 0x20000 }
sub O_DIRECT    (){  0x8000 }
sub O_DIRECTORY (){ 0x10000 }
sub O_NOATIME   (){ 0x40000 }

sub errno2mips($) {
   # TODO(pts): Implement this correctly, `use Errno' etc.
   $_[0]*1
}

sub mips2omode($) {
   my $mmode = shift;

   my $omode = 0;

   $omode |= Fcntl::O_RDONLY() if ($mmode & O_ACCMODE) == O_RDONLY;
   $omode |= Fcntl::O_WRONLY() if ($mmode & O_ACCMODE) == O_WRONLY;
   $omode |= Fcntl::O_RDWR()   if ($mmode & O_ACCMODE) == O_RDWR;

   for my $mode (qw(
      APPEND SYNC NONBLOCK CREAT TRUNC EXCL NOCTTY
      ASYNC NOFOLLOW DIRECT DIRECTORY NOATIME
   )) {
      # !! TODO(pts): Make this much faster, no eval.
      eval "\$omode |= Fcntl::O_$mode() if \$mmode & O_$mode";
   }

   $omode
}

my $enosys = sub {
   warn "MIPS I Linux emulator: unimplemented syscall $r2\n";
};

# System call numbers are in the mipso32 column of
# https://fedora.juszkiewicz.com.pl/syscalls.html
my @syscall;

############################################

my @fh;
my @dh; # directory-handles, HACK
my $strace;


{
   for my $fd (3..9) {
      my_open(my $fh, "+>&=$fd") or next;
      $fh[$fd] = $fh;
   }
   for my $fd (0..2) {
      my_open(my $fh, "+>&$fd") or next;
      $fh[$fd] = $fh;
   }
}
sub fd_valid($) {
   !($_[0] & ~65535)
   && $fh[$_[0]]
}

############################################

sub strace($;@) {
   $strace = $#_
      ? sprintf $_[0], @_[1..$#_]
      : shift;
}

sub newfd($) {
   my $fd = 0;
   ++$fd while $fh[$fd];
   $fh[$fd] = $_[0];
   $fd
}

sub reify_fds {
   my $top = 512;

   for my $fd (0..$#fh) {
      next unless $fh[$fd];

      POSIX::dup2 fileno $fh[$fd], $top + $fd;
      close $fh[$fd];
   }

   for my $fd (0..$#fh) {
      next unless $fh[$fd];

      POSIX::dup2 $top + $fd, $fd;
      POSIX::close $top + $fd;

      my_open my $fh, "+<&=$fd"
        or die;

     $fh[$fd] = $fh;
   }
}

############################################

sub newstat {
   my $buf = shift;

   if (@_) {
      my $blocks = ($_[12] or 0);  # Perl 5.004 may have an empty string here.
      my $stat = pack "N x12 NNNNN x8 N x4 NN NN NN N N x56",
         $_[ 0], # dev
         $_[ 1], # ino
         $_[ 2], # mode
         $_[ 3], # nlink
         $_[ 4], # uid
         $_[ 5], # gid
         $_[ 6], # rdev
         $_[ 7], # size
         $_[ 8], 0, # atime
         $_[ 9], 0, # mtime
         $_[10], 0, # ctime
         ($_[11] or 0), # blksize
         $blocks; # blocks

      memset $buf, $stat;

      return 0;
   }

   -errno2mips($! + 0)
};

sub stat64 {
   my $buf = shift;

   if (@_) {
      my $blocks = ($_[12] or 0);  # Perl 5.004 may have an empty string here.
      my $stat = pack "N x12 NN NNNNN x12 NN NN NN NN N x4 NN",
         $_[ 0], # dev
         $use_int32 ? int($_[1] / 4294967296) : $_[ 1] >> 32, $_[1], # ino
         $_[ 2], # mode
         $_[ 3], # nlink
         $_[ 4], # uid
         $_[ 5], # gid
         $_[ 6], # rdev
         $use_int32 ? int($_[7] / 4294967296) : $_[ 7] >> 32, $_[7], # size
         $_[ 8], 0, # atime
         $_[ 9], 0, # mtime
         $_[10], 0, # ctime
         ($_[11] or 0), # blksize
         $use_int32 ? int($blocks / 4294967296) : $blocks >> 32, $blocks; # blocks

      memset $buf, $stat;

      return 0;
   }

   -errno2mips($! + 0)
};

sub sys_fcntl {
   my ($fd, $cmd, $arg) = @_;
   strace "fcntl (%d, %x, %x)", $fd, $cmd, $arg;
   fd_valid $fd or return -(EBADF);

   if ($cmd == 0) { # F_DUPFD
      ++$arg while $fh[$arg];
      my_open my $fh, "+<&" . fileno($fh[$fd])
         or return -errno2mips($! + 0);
      $fh[$arg] = $fh;
      return $arg;
   } elsif ($cmd == 1) { # F_GETFD
      return fcntl $fh[$fd], Fcntl::F_GETFD(), 0;
   } elsif ($cmd == 2) { # F_SETFD
      return +(fcntl $fh[$fd], Fcntl::F_SETFD(), $arg+0)
         ? 0 : -errno2mips($! + 0);
   } elsif ($cmd == 3) { # F_GETFL
      return O_RDWR; # HACK
   } else {
      # 4 F_SETFL
      warn sprintf"unknown fcntl %d,%x,%x\n", $fd, $cmd, $arg;
   }

   -(ENOSYS)
};

############################################

$syscall[4001] = sub { # exit
   strace "exit ($_[0])";
   exit $_[0];
};
$syscall[4002] = sub { # fork
   strace "fork";

   my $pid = fork;
   return -errno2mips($! + 0) unless defined $pid;
   $pid
};
$syscall[4003] = sub { # read
   my ($fd, $rbuf, $count) = @_;
   strace "read (%d, %x, %d)", $fd, $rbuf, $count;

   $count = sysread $fh[$fd], my($buf), $count;

   memset $rbuf, $buf;

   defined $count ? $count : -errno2mips($! + 0)
};

$syscall[4004] = sub { # write
   my ($fd, $buf, $count) = @_;
   strace "write (%d, %x, %d)", $fd, $buf, $count;

   $count = syswrite $fh[$fd], memget($buf, $count), $count;
   defined $count ? $count : -errno2mips($! + 0)
};
$syscall[4005] = sub { # open
   my ($path, $flags, $mode) = @_;
   $path = memstr $path;
   strace "open (%s, %x, %o)", $path, $flags, $mode;

   if (my_opendir my $dh, $path) {#d#
      my_open my $fh, "</dev/null"or die;
      my $fd = newfd $fh;
      $dh[$fd] = $dh;
      return $fd;
   }

   my_sysopen my $fh, $path, mips2omode $flags, $mode
      or return -errno2mips($! + 0);

   newfd $fh
};
$syscall[4006] = sub { # close
   my ($fd) = @_;
   strace "close ($fd)";
   fd_valid $fd or return -(EBADF);

   undef $dh[$fd];#d#
   (close delete $fh[$fd])
      ? 0 : -errno2mips($! + 0)
};

$syscall[4010] = sub { # unlink
   my ($path) = @_;
   $path = memstr $path;
   strace "unlink (%s)", $path;

   (defined unlink $path)
      ? 0 : -errno2mips($! + 0)
};
$syscall[4011] = sub { # execve
   my ($path, $argv, $envv) = @_;
   $path = memstr $path;

   for my $vec ($argv, $envv) {
      my $addr = $vec;
      $vec = [];
      while () {
         my $ptr = unpack "N", memget $addr, 4
            or last;
         push @$vec, memstr $ptr;
         $addr += 4;
      }
   }

   local %ENV;
   for (@$envv) { $ENV{$1} = $2 if /([^=]*)=(.*)/s }

   ($path, $argv->[0]) = ($argv->[0], $path);

   reify_fds;
     
   die "unexpected success from exec" if exec {$path} @$argv;

   # not normally printed...
   strace "execve (%s, [%s], [%s])", $path, (join "|", @$argv), (join "|", @$envv);

   -errno2mips($! + 0)
};
$syscall[4012] = sub { # chdir
   my $path = memstr $_[0];
   strace "chdir (%s)", $path;

   (chdir $path) ? 0 : -errno2mips($! + 0)
};
$syscall[4013] = sub { # time
   my ($rbuf) = @_;
   strace "time (%x)", $rbuf;

   my $time = DETSYS ? 2000000000 : time;

   memset $rbuf, pack "N", $time;
   $time
};

$syscall[4020] = sub {
   strace "getpid ()";
   return 44 if DETSYS;
   $$
};
$syscall[4020] = sub { strace "getpid ()"; $$ };

$syscall[4024] = sub { strace "getuid ()"; $< };

$syscall[4033] = sub { # access
   my ($path, $mode) = @_;
   $path = memstr $path;
   strace "acess (%s, %o)", $path, $mode;

   0

};

$syscall[4037] = sub { # kill
   strace "kill ($_[0], $_[1])";
   
   (kill $_[1], $_[0]) # todo signal numbers?
      ? 0 : -errno2mips($! + 0)
};

$syscall[4041] = sub { # dup
   my ($fd) = @_;
   strace "dup ($fd)";
   fd_valid $fd or return -(EBADF);

   my_open my $fh, "+<&" . fileno($fh[$fd])
      or return -errno2mips($! + 0);

   newfd $fh
};
$syscall[4042] = sub { # sysm_pipe
   strace "sysm_pipe ()";

   pipe my $r, my $w
      or return -errno2mips($! + 0);

   $r = newfd $r;
   $w = newfd $w;

   strace "sysm_pipe ($r, $w)";

   $r3 = $w;
         $r
};

$syscall[4045] = sub { # brk
   strace "brk (%x)", $_[0];
   my $brk = $_[0];
   $brk = MINBRK if $brk < MINBRK;
   $brk
}; # brk

$syscall[4047] = sub { strace "getgid ()" ; $( };

$syscall[4049] = sub { strace "geteuid ()"; $> };
$syscall[4050] = sub { strace "getegid ()"; $) };

$syscall[4054] = sub { # ioctl
   my ($fd, $req, $arg) = @_;
   strace "ioctl (%d, %x, %x)", $fd, $req, $arg;
   fd_valid $fd or return -(EBADF);

   if ($req == 0x540d) { # TCGETS
      if (-t $fh[$fd]) {
         memset $arg, pack "NNNN C C23";
         return 0;
      }
   } elsif ($req == 0x540f) { # TCSETW
      return 0;
   } elsif ($req == 0x40047477) { # TIOCGPGRP # irix???
      memset $arg, pack "N", getpgrp; # hacky, but does...
      return 0;
   } elsif ($req == 0x80047476) { # TIOCSPGRP # irix???
      return 0; # whatever you say...
   } elsif ($req == 0x40087468) { # TIOCGWINSZ
      return -(ENOSYS);
   } else {
      warn sprintf"unknown ioctl %d,%x,%x\n", $fd, $req, $arg;
   }

   -(ENOTTY)
};
$syscall[4055] = \&sys_fcntl; # fcntl

$syscall[4057] = sub { # getpgid
   strace "getpgid ($_[0])";
   return 44 if DETSYS;
   $_[0] == $$
      ? getpgrp : $$ # hacky, but it's a bsd'ism
};

$syscall[4060] = sub { strace "umask (%o)", $_[0]; umask $_[0] };

$syscall[4063] = sub { # dup2
   my ($fd1, $fd2) = @_;
   strace "dup2 ($fd1, $fd2)";
   fd_valid $fd1 or return -(EBADF);

   my_open my $fh, "+<&" . fileno($fh[$fd1])
      or return -errno2mips($! + 0);

   $dh[$fd2] = $dh[$fd1];
   $fh[$fd2] = $fh;
   $fd2
};

$syscall[4064] = sub {
   strace "getppid ()";
   return 43 if DETSYS;
   getppid
};
$syscall[4065] = sub {
   strace "getpgrp ()";
   return 43 if DETSYS;
   getpgrp
};

$syscall[4075] = sub { # setrlimit
   my ($resource, $rlim) = @_;
   strace "setrlimit (%d, %x)", $resource, $rlim;

   0
};
$syscall[4076] = sub { # getrlimit
   my ($resource, $rlim) = @_;
   strace "getrlimit (%d, %x)", $resource, $rlim;

   -(ENOSYS)
};

$syscall[4078] = sub { # gettimeofday
   my ($tv, $tz) = @_;
   strace "gettimeofday (%x, %x)", $tv, $tz;

   my ($s, $m) = DETSYS ? (2000000000, 0) : Time::HiRes::gettimeofday;
   memset $tv, pack "NN", $s, $m if $tv;
   memset $tz, pack "NN", 0, 0 if $tz; # minuteswest, dsttime

   0
};

$syscall[4080] = sub { # getgroups
   # TODO(pts): Implement this properly, using additional numbers in $).
   0
};

$syscall[4171] = sub { # getpeername
   # TODO(pts): Implement this properly, with `use Socket;'. Can we do it
   #            with a filehandle?
   -(ENOTSOCK)
};

$syscall[4090] = sub {
   # SYSCALL_DEFINE6(mips_mmap, unsigned long, addr, unsigned long, len,
   #         unsigned long, prot, unsigned long, flags, unsigned long,
   #         fd, off_t, offset)

   strace "mips_mmap (%x, %d, %x, %x, %d, %d)", @_;
   -(ENOSYS)
};

$syscall[4097] = sub { # setpriority
   # ...
   -(ENOSYS)
};

$syscall[4099] = sub { # statfs
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "statfs (%s, %x)", $path, $buf;

   -(ENOSYS)
};
$syscall[4100] = sub { # fstatfs
   my ($fd, $buf) = @_;
   strace "fstatfs (%d, %x)", $fd, $buf;

   -(ENOSYS)
};

$syscall[4106] = sub { # newstat
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "newstat (%s, %x)", $path, $buf;

   newstat $buf, stat $path
};
$syscall[4107] = sub { # newlstat
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "newlstat (%s, %x)", $path, $buf;

   newstat $buf, lstat $path
};
$syscall[4108] = sub { # newfstat
   my ($fd, $buf) = @_;
   strace "newfstat (%d, %x)", $fd, $buf;

   newstat $buf, stat $fh[$fd]
};

$syscall[4114] = sub { # wait4
   my ($pid, $statusbuf, $options, $rusage) = @_;
   $pid = unpack "l", pack "L", $pid;  # !! More consistent sign conversion.
   strace "wait4 (%d, %x, %x, %x)", $pid, $statusbuf, $options, $rusage;

   memset $rusage, "\x00" x 72
      if $rusage;
   
   $pid = waitpid $pid, $options;

   memset $statusbuf, pack "N", $? if $statusbuf;

   $pid >= 0 ? $pid : -errno2mips($! + 0)
};

$syscall[4122] = sub { # newuname
   my ($buf) = @_;
   strace "newuname (%x)", $buf;

   memset $buf, pack "a65 a65 a65 a65 a65 a65", #d#
      "Linux",  # "sysname",
      "nodename",
      "2.6.32.71-emulator",  # "release",
      "#emulator",  # "version",
      "mips",  # "machine",
      "(none)",  # "domainname"
      ;
   0
};

$syscall[4140] = sub { # llseek
   my ($fd, $high, $low, $result, $whence) = @_;
   strace "llseek (%d, %x, %08x, %x, %d)", $fd, $high, $low, $result, $whence;
   # Some systems don't support high-absolute-value 64-bit seek offsets for
   # sysseek.
   #
   # TODO(pts): $use_int32: At least we should check the return value.
   my $ofs = $low +
       ($use_int32 ? 4294967296 * ($high - ($high & 2147483648) * 2) :
       $high << 32);

   my $res = sysseek $fh[$fd], $ofs, $whence;

   memset $result, pack "NN",
       ($use_int32 ? int($res / 4294967296) : $res >> 32), $res;

   defined $res
      ? 0 : -errno2mips($! + 0)
};

$syscall[4194] = sub { # sigaction
   my ($signum, $act, $oldact) = @_;
   strace "sigaction (%d, %x, %x)", $signum, $act, $oldact;
   -(ENOSYS)
};
$syscall[4195] = sub { # sigprocmask
   my ($how, $set, $oldset) = @_;
   strace "sigprocmask ($how, $set, $oldset)";

   -(ENOSYS)
};

$syscall[4203] = sub { # getcwd
   if (DETSYS) {
      return -(ERANGE) if 1 >= $_[1];
      memset $_[0], "/\x00";
      return 2;
   }
   my $cwd = Cwd::getcwd;
   strace "getcwd (%x, %d)", $_[0], $_[1];

   if ((length $cwd) < $_[1]) {
      memset $_[0], "$cwd\x00";
      return 1 + length $cwd;
   } else {
      return -(ERANGE);
   }
};

$syscall[4213] = sub { # stat64
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "stat64 (%s, %x)", $path, $buf;

   stat64 $buf, stat $path
};
$syscall[4214] = sub { # lstat64
   my ($path, $buf) = @_;
   $path = memstr $path;
   strace "lstat64 (%s, %x)", $path, $buf;

   stat64 $buf, lstat $path
};
$syscall[4215] = sub { # fstat64
   my ($fd, $buf) = @_;
   strace "fstat64 (%d, %x)", $fd, $buf;

   stat64 $buf, stat $fh[$fd]
};

$syscall[4219] = sub { # getdents64
   my ($fd, $dirp, $count) = @_;
   strace "getdents64 (%d, %x, %d)", $fd, $dirp, $count;

   my $name = readdir $dh[$fd];

   return 0 unless defined $name;

   my $ino = -1;
   my $type = 0;

   my $entry = pack "NN NN n C a*",
      ($use_int32 ? int($ino / 4294967296) : $ino >> 32), $ino,
      0, 0, # offset
      (length $name) + 20,
      $type,
      $name;

   $entry .= "\0";
   memset $dirp, $entry;
   length $entry
};
$syscall[4220] = \&sys_fcntl; # fcntl64

$syscall[4283] = sub { # set_thread_area
   my ($udesc) = @_;

   strace "set_thread_area (%x)", $udesc;

   -(ENOSYS)
};

$syscall[4300] = sub { # faccessat
   my ($dirfd, $path, $mode, $flags) = @_;

   strace "faccessat (%d, %s, %o, %x)", $dirfd, $path, $mode, $flags;

   0 # #d# grant any access
};

sub sys {
   my @args =  map $_*1,  # TODO(pts): Any faster than *1?
      $r4, $r5, $r6, $r7, # first four args in regs
      # extra arguments on stack
      vec($mem[($r29 + 16) >> ADDR_SHIFT], (($r29 + 16) >> 2) & ADDR_MASK, 32) | 0,
      vec($mem[($r29 + 20) >> ADDR_SHIFT], (($r29 + 20) >> 2) & ADDR_MASK, 32) | 0,
      vec($mem[($r29 + 24) >> ADDR_SHIFT], (($r29 + 24) >> 2) & ADDR_MASK, 32) | 0,
      vec($mem[($r29 + 28) >> ADDR_SHIFT], (($r29 + 28) >> 2) & ADDR_MASK, 32) | 0,
   ;

   #print STDERR "SYSCALL $r2 (@args)\n";
   $strace = "$r2 (@args)" if STRACE;
   my $retval = ($syscall[$r2] or $enosys)->(@args);
   print STDERR "$$ SYS_$strace = $retval\n" if STRACE;

   if ($retval > -4096 && $retval < 0) {
      $r2 = -$retval;
      $r7 = 1;
   } else {
      $r2 = $retval;
      $r7 = 0;
   }
}

#############################################################################
# mips i big endian cpu emulator

############################################
# specials (opcode 0)

my ($s, $t, $i, $c0, $c1); # "global" for speed

my @special = ('die "special ". ($insn & 63) . " not supported"') x 64;

$special[ 0] = "RD = shl(RT, SA)"; # sll

$special[ 2] = 'RD =  RT                       >> SA             '; # srl

$special[ 3] = 'RD = MASK32[(RT - ((RT & B31) * 2)) >> SA       ]'; # sra
$special[ 4] = 'RD =  shl(RT, (RS & 31))'; # sllv

$special[ 6] = 'RD =   RT                     >> (RS & 31)       '; # srlv
$special[ 7] = 'RD = MASK32[(RT - ((RT & B31) * 2)) >> (RS & 31)]'; # srav
$special[ 8] = '               $pc = RS >> 2'; # jr
$special[ 9] = 'RD = $pc << 2; $pc = RS >> 2'; # jalr

$special[12] = 'sys';
$special[13] = 'die sprintf "BREAK (%08x)", $insn'; # break

$special[16] = 'RD = $hi'; # mfhi
$special[17] = '$hi = RS'; # mthi
$special[18] = 'RD = $lo'; # mflo
$special[19] = '$lo = RS'; # mtlo

if ($use_int32) {
   # It works with both 32-bit and 64-bit Perl, but only with `no integer'.
   #
   # It is doing https://en.wikipedia.org/wiki/IEEE_754 64-bit float
   # (double) arithmetics with 53-bit significand, thus it's OK to multiply
   # a 16-bit and a 32-bit unsigned integer.
   $special[24] =  '# mult RS RT;
      if (RS <= 2147483647 and RT <= 2147483648 and ($s = RS * RT) <= 9007199254740991) {  # Shortcut.
         $lo = MASK32[$s];
         $hi = ($s - $lo) / 4294967296;
      } else {  # TODO(pts): Can we do it any shorter?
         $s = RS;
         $t = RT;
         my $sign = 1;
         ($s, $sign) = (4294967296 - $s, -$sign) if $s > 2147483647;
         ($t, $sign) = (4294967296 - $t, -$sign) if $t > 2147483647;
         $lo = $s % 65536;
         $hi = ($s - $lo) / 65536 * $t;
         $lo *= $t;
         $t = MASK16[$hi];
         $lo += $t * 65536;
         $hi = ($hi - $t) / 65536;
         $t = MASK32[$lo];
         $hi += ($lo - $t) / 4294967296;
         $lo = $t;
         if ($sign < 0) {
            if ($lo) {
               $lo = 4294967296 - $lo;
               $hi = 4294967295 - $hi;
            } else {
               $hi = 4294967296 - $hi;
            }
         }
      }
      #printf STDERR "CALL mult(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
      ';
   $special[25] = ' # multu RS RT;
      $s = RS * RT;
      if ($s <= 9007199254740991) {  # Shortcut.
         $lo = MASK32[$s];
         $hi = ($s - $lo) / 4294967296;
      } else {
         $lo = RS % 65536;
         $hi = (RS - $lo) / 65536 * RT;
         $lo *= RT;
         $t = MASK16[$hi];
         $lo += $t * 65536;
         $hi = ($hi - $t) / 65536;
         $t = MASK32[$lo];
         $hi += ($lo - $t) / 4294967296;
         $lo = $t;
      }
      #printf STDERR "CALL multu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
      ';
   $special[26] = ' # div RS RT;
      $s = RS - ((RS & B31) * 2);
      $t = RT - ((RT & B31) * 2)
         or return;
      # Sign of the remainder ($hi) will be the sign of $t with no integer (here).
      # Sign of the remainder ($hi) would be the sign of $s with use integer.
      $hi = $s % $t;
      $hi -= $t if $hi and (($s > 0 and $t < 0) or ($s < 0 and $t > 0));
      $lo = MASK32[($s - $hi) / $t];
      $hi = MASK32[$hi];
      #printf STDERR "CALL div(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[27] = ' # divu RS RT;
      RT or return;
      $hi = RS % RT;
      $lo = (RS - $hi) / RT;
      #printf STDERR "CALL divu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
} else {
   $special[24] =  '# mult RS RT;64
      $lo = (RS - ((RS & B31) << 1))
          * (RT - ((RT & B31) << 1));
      $hi = ($lo >> 32) & M32;
      $lo &= M32;
      #printf STDERR "CALL mult(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[25] = ' # multu RS RT;64
      $lo = RS * RT;
      $hi = ($lo >> 32) & M32;
      $lo &= M32;
      #printf STDERR "CALL multu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[26] = ' # div RS RT;64
      $s = RS - ((RS & B31) << 1);
      $t = RT - ((RT & B31) << 1)
         or return;

      $lo = ($s / $t) & M32;
      $hi = ($s % $t) & M32;
      #printf STDERR "CALL div(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
   $special[27] = ' # divu RS RT;64
      RT or return;

      $lo = RS / RT;
      $hi = RS % RT;
      #printf STDERR "CALL divu(0x%08x,0x%08x)=(0x%08x,0x%08x)\n", RS, RT, $lo, $hi;
   ';
}

$special[32] = 'die "add instruction unsupported"';
$special[33] = "RD = MASK32[RS + RT]"; # addu
$special[34] = 'die "sub instruction unsupported"';
$special[35] = "RD = MASK32[RS - RT]"; # subu
#$special[32] = $special[33]; # add # buggy, does not trap #d#
#$special[34] = $special[35]; # sub # buggy, does not trap #d#

$special[36] = "RD =  RS & RT       "; # and
$special[37] = "RD =  RS | RT       "; # or
$special[38] = "RD =  RS ^ RT       "; # xor
$special[39] = "RD = (RS ^ RT) ^ M32"; # nor

$special[42] = "RD = (RS - ((RS & B31) * 2)) < (RT - ((RT & B31) * 2))"; # slt
$special[43] = "RD =  RS                     <  RT                    "; # sltu

############################################
# regimm (opcode 1)

my @regimm = ('die "regimm " . (($insn >> 16) & 31) . " not supported"') x 32;

# !! TODO(pts): What if $pc overflows or underflows here?
$regimm[ 0] = '                    $pc += IMM - 1  if     RS & 0x80000000'; # bltz
$regimm[16] = '($r31 = $pc << 2), ($pc += IMM - 1) if     RS & 0x80000000'; # bltzal
$regimm[ 1] = '                    $pc += IMM - 1  unless RS & 0x80000000'; # bgez
$regimm[17] = '($r31 = $pc << 2), ($pc += IMM - 1) unless RS & 0x80000000'; # bgezal bal

############################################
# others

my @opsrc;
$opsrc[ 2] = '                 $pc = ($pc & 0x3c000000) | ($insn & 0x03ffffff)'; # j
$opsrc[ 3] = '$r31 = $pc << 2; $pc = ($pc & 0x3c000000) | ($insn & 0x03ffffff)'; # jal
$opsrc[ 4] = '($pc += IMM - 1) if RS == RT'; # beq beqz b
$opsrc[ 5] = '($pc += IMM - 1) if RS != RT'; # bne bnez
$opsrc[ 6] = '($pc += IMM - 1) if !RS || RS >= 0x80000000'; # blez
$opsrc[ 7] = '($pc += IMM - 1) if  RS && RS <  0x80000000'; # bgtz
$opsrc[ 8] = 'die "addi instruction unsupported"'; # addi
$opsrc[ 9] = 'RT = MASK32[RS + IMM]'; # addiu
$opsrc[10] = 'RT = ((RS - ((RS & B31) * 2))) <  IMM         '; # slti
$opsrc[11] = 'RT =   RS                      < (MASK32[IMM])'; # sltiu
$opsrc[12] = 'RT = RS & IMMU'; # andi
$opsrc[13] = 'RT = RS | IMMU'; # ori
$opsrc[14] = 'RT = RS ^ IMMU'; # xori
$opsrc[15] = 'RT = IMMU << 16'; # lui
$opsrc[32] = ' # lb
   $i = RS + IMM;
   $s = (~$i & 3) << 3;
   $s = LOADI >> $s;
   RT = MASK32[($s &  M8) - (($s &  B7) * 2)];
';
$opsrc[33] = ' # lh
   $i = RS + IMM;
   $s = (~$i & 2) << 3;
   $s = LOADI >> $s;
   RT = MASK32[($s & M16) - (($s & B15) * 2)];
';
$opsrc[34] = ' # lwl
   $i = RS + IMM;
   $s = ($i & 3) << 3;
   $i = LOADI;
   RT = (RT & (M32 >> (32 - $s))) | (shl($i, $s));
';
$opsrc[35] = ' # lw
   $i = RS + IMM;
   RT = LOADI;
';
$opsrc[36] = ' # lbu
   $i = RS + IMM;
   $s = (~$i & 3) << 3;
   RT = (LOADI >> $s) & M8;
';
$opsrc[37] = ' # lhu
   $i = RS + IMM;
   $s = (~$i & 2) << 3;
   RT = (LOADI >> $s) & M16;
';
$opsrc[38] = ' # lwr
   $i = RS + IMM;
   $s = (($i & 3) + 1) << 3;
   $i = LOADI;
   # TODO(pts): Do the shl part with masking.
   RT = $s == 32 ? $i : shl(RT >> $s, $s) | ($i >> (32 - $s));
';
$opsrc[40] = ' # sb
   $i = RS + IMM;
   $s = (~$i & 3) << 3;
   $t = LOADCI;
   vec($mem[$c0], $c1, 32) = ($t & ~(M8  << $s)) | (RT & M8 ) << $s;
';
$opsrc[41] = ' # sh
   $i = RS + IMM;
   $s = (~$i & 2) << 3;
   $t = LOADCI;
   vec($mem[$c0], $c1, 32) = ($t & ~(M16 << $s)) | (RT & M16) << $s;
';
$opsrc[42] = ' # swl
   $i = RS + IMM;
   $s = ((~$i & 3) + 1) << 3;
   $t = LOADCI;
   # TODO(pts): Do the shl part with masking.
   vec($mem[$c0], $c1, 32) =
       $s == 32 ? RT : shl($t >> $s, $s) | (RT >> (32 - $s));
';
$opsrc[43] = ' # sw
   $i = RS + IMM;
   vec($mem[$i >> ADDR_SHIFT], ($i >> 2) & ADDR_MASK, 32) = RT;
';

$opsrc[46] = ' # swr
   $i = RS + IMM;
   $s = (($i & 3) + 1) << 3;
   $t = LOADCI;
   # TODO(pts): Do the shl part with masking.
   vec($mem[$c0], $c1, 32) =
       $s == 32 ? RT : $t & (M32 >> $s) | shl(RT, 32 - $s);
';
# TODO(pts): eval each opcode once with some default registers, just to check
# for syntax errors.

# 0x7c03e83b rdhwr $3, $29 ($29=tls)- emulated by kernel normally, for thread support

sub get_insn($) {
   my $insn = $_[0];
   $insn2sub{$insn} ||= do {
      die "nop unexpected here" if !$insn;
      my $opcode = $insn >> 26;
      my $src = $opcode > 1 ? $opsrc[$opcode] :
          $opcode == 0 ? $special[$insn & 63] : $regimm[($insn >> 16) & 31];
      die sprintf("unknown instruction opcode=%d insn=0x%08x", $opcode, $insn)
          if !defined($src);

      # TODO(pts): Make this faster by replacing /ge with /g, and precomputing
      #            these values, e.g. $imm instead of IMM. It's important that
      #            the `eval' below will see the resulting constants.
      $src =~ s/\bIMM\b/($insn & M16) - (($insn & B15) << 1)/ge; # 16 bit signed immediate
      $src =~ s/\bIMMU\b/$insn & M16/ge;                         # 16 bit unsigned immediate

      $src =~ s/\bSA\b/($insn >> 6) & 31/ge;                     # shift amount

      $src =~ s/\bRS\b/'$r' . (($insn >> 21) & 31)/ge;           # s register
      $src =~ s/\bRT\b/'$r' . (($insn >> 16) & 31)/ge;           # t register
      $src =~ s/\bRD\b/'$r' . (($insn >> 11) & 31)/ge;           # d register

      $src =~ s/\bLOADI\b/(vec(\$mem[\$i >> ADDR_SHIFT], (\$i >> 2) & ADDR_MASK, 32)$loadi_or0)/;
      $src =~ s/\bLOADCI\b/(vec(\$mem[\$c0 = \$i >> ADDR_SHIFT], \$c1 = (\$i >> 2) & ADDR_MASK, 32)$loadi_or0)/;
      # This always works, but it is slow:
      # $src =~ s/\bMASK32\[([^\]\n]+)\]/mask32($1)/g;
      # $src =~ s/\bMASK16\[([^\]\n]+)\]/(mask32($1) & 65535)/g;
      if ($mask_mode == 0) {
        $src =~ s/\bMASK32\[([^\]\n]+)\]/(($1) | 0)/g;
        $src =~ s/\bMASK16\[([^\]\n]+)\]/(($1) & 65535)/g;
      } elsif ($mask_mode == 1) {
        $src =~ s/\bMASK32\[([^\]\n]+)\]/(($1) % 4294967296)/g;
        $src =~ s/\bMASK16\[([^\]\n]+)\]/(($1) % 65536)/g;
      } else {
        $src =~ s/\bMASK32\[([^\]\n]+)\]/(($1) & M32)/g;
        $src =~ s/\bMASK16\[([^\]\n]+)\]/(($1) & M16)/g;
      }

      $src =~ s/\$r0 = //g; # optimize away r0 assignments
      $src =~ s/\$r0\b/(0)/g; # optimise away r0 access

      my $cb = eval "sub { $src }" || die "$insn<$src>: $@";
      if (PRCPU or PRDIFF) { $src =~ s/\s+/ /g; $insn2src{$insn} = $src }
      $cb
   }
}

sub cpu_reset($) {
   $pc = $_[0] >> 2;

   $r0  = 0;

          $r1  = $r2  = $r3  = $r4  = $r5  = $r6  = $r7  =
   $r8  = $r9  = $r10 = $r11 = $r12 = $r13 = $r14 = $r15 =
   $r16 = $r17 = $r18 = $r19 = $r20 = $r21 = $r22 = $r23 =
   $r24 = $r25 = $r26 = $r27 = $r28 =        $r30 =
   $hi  = $lo  = 0xdeadbeef;

   $r2  = 0;
   $r29 = STACK;
   $r31 = 0;

   $delay = 0;  # start with a nop
}

sub get_state() {
   ([@mem], $pc, $hi, $lo, $delay,  # cpu state
    $r0 , $r1 , $r2 , $r3 , $r4 , $r5 , $r6 , $r7 ,
    $r8 , $r9 , $r10, $r11, $r12, $r13, $r14, $r15,
    $r16, $r17, $r18, $r19, $r20, $r21, $r22, $r23,
    $r24, $r25, $r26, $r27, $r28, $r29, $r30, $r31)
}

sub diff_state($$$) {
  my($st0, $st1, $insn) = @_;
  my @d;
  if ($st0->[1] != $st1->[1]) { push @d, sprintf("pc=0x%08x", $st1->[1] >> 2) }
  if ($st0->[2] != $st1->[2]) { push @d, sprintf("hi=0x%08x", $st1->[2]) }
  if ($st0->[3] != $st1->[3]) { push @d, sprintf("lo=0x%08x", $st1->[3]) }
  if ($st0->[4] != $st1->[4]) { push @d, sprintf("delay=0x%08x", $st1->[4]) }
  for (my $i = 0; $i < 31; ++$i) {
    if ($st0->[5 + $i] != $st1->[5 + $i]) { push @d, sprintf("r$i=0x%08x", $st1->[5 + $i]) }
  }
  my $pgc0 = @{$st0->[0]};
  my $pgc1 = @{$st1->[0]};
  my $pgc = $pgc0 > $pgc1 ? $pgc0 : $pgc1;
  for (my $pgi = 0; $pgi <= $pgc; ++$pgi) {
    next if !defined($st0->[0][$pgi]) and !defined($st1->[0][$pgi]);
    my $pg0 = \$st0->[0][$pgi];
    my $pg1 = \$st1->[0][$pgi];
    if ($$pg0 ne $$pg1) {
      push @d, sprintf("pg0x%x", $pgi);
      my $size = ((length($$pg0) > length($$pg1) ? length($$pg0) : length($$pg1)) + 3) >> 2;
      for (my $i = 0; $i < $size; ++$i) {
        my $v0 = vec($$pg0, $i, 32) | 0;
        my $v1 = vec($$pg1, $i, 32) | 0;
        push @d, sprintf("mem0x%08x=%08x", $pgi << 16 | $i << 2, $v1) if $v0 != $v1;
      }
    }
  }
  push @d, 'none' if !@d;
  my $src = $insn2src{$insn};
  $src =~ s@\A(# *(?:mult|multu|div|divu) [^;]*;).*@$1@s;
  "DIFF: $src: @d\n"
}

sub cpu_run();
if (!PRIPS && !PRCPU && !PRDIFF) {  # Hot path for non-debug mode.
   if ($loadi_or0) {
      *::cpu_run = sub () {  # Shortcut for nondebug mode.
         while () {
            my $insn = $delay;
            $delay = vec($mem[$pc >> (ADDR2_SHIFT)], $pc & ADDR_MASK, 32) | 0;
            die "pc overflow" if ++$pc > 0x3fffffff;
            ($insn2sub{$insn} or get_insn($insn))->();
         }
      }
   } else {
      *::cpu_run = sub () {  # Shortcut for nondebug mode.
         while () {
            my $insn = $delay;
            $delay = vec($mem[$pc >> (ADDR2_SHIFT)], $pc & ADDR_MASK, 32);
            die "pc overflow" if ++$pc > 0x3fffffff;
            ($insn2sub{$insn} or get_insn($insn))->();
         }
      }
   }
} else {
   *::cpu_run = sub () {
      while () {
         if (PRIPS) {
            unless (++$::n & 0xfffff) {
               no integer;
               my_open my $tty, ">/dev/tty";
               printf {$tty} "%g ips\n", $::n / (Time::HiRes::time - $::t0);
               $::n = 0; $::t0 = Time::HiRes::time;#d#
            }
         }

         cpu_pr() if PRCPU;
         my $insn = $delay;
         $delay = vec($mem[$pc >> (ADDR2_SHIFT)], $pc & ADDR_MASK, 32) | 0;
         ++$pc;
         die "pc overflow" if $pc > 0x3fffffff;
         if (PRDIFF) {
           my @st0 = get_state();
           ($insn2sub{$insn} or get_insn($insn))->();
           my @st1 = get_state();
           print STDERR diff_state(\@st0, \@st1, $insn);
         } else {
           ($insn2sub{$insn} or get_insn($insn))->();
         }
      }
   }
}

#############################################################################

sub mips_exec($$;$$) {
   my ($path, $argv, $envv, $auxv) = @_;

   mem_reset;

   my $file = $path;
   if (ref $path ne 'GLOB') {
     undef $file;
     # Escape filename for Perl 5.004_04.
     my $path2 = $path =~ m@\A[\s&]@ ? "./$path" : $path;
     die "open $path: $!" if !my_open($file, "<$path2");
   }

   my $elf_header;
   my $base_ofs = tell($file);
   die "seek: $!" if !seek($file, $base_ofs, 0);
   die "read: $!" if 0x32 != (read($file, $elf_header, 0x32) or 0);
   if ($elf_header =~ m@\A#!.*perl@s) {
     die "read: $!" if !defined(read($file, $elf_header, 131022, 0x32));
     my $i = index($elf_header, "\n_"."_"."DATA"."_"."_\n");
     if ($i > 0) {
       $elf_header = substr($elf_header, $i += 10, 0x32);
       $base_ofs += $i;
     }
   }

   # 32 bit, msb, elf version
   "\x7fELF\x01\x02\x01" eq substr $elf_header, 0, 7
      or die "not an elf file, or wrong class, encoding or version";

   my ($type, $machine, $unused_version, $entry, $phoff, $unused_shoff,
       $unused_flags, $unused_ehsize, $phentsize, $phnum,
      ) = unpack "x16nnNNNNNnnn", $elf_header;

   $type == 2
      or die "file not an executable";

   $machine == 8
      or die "file not mips r3000 big endian";

   die "seek: $!" if !seek($file, $phoff + $base_ofs, 0);
   my $phents;
   die "read phents: $!" if 0x20 * $phnum !=
       (read($file, $phents, 0x20 * $phnum) or 0);
   for (my $phi = 0; $phi < $phnum; ++$phi) {
      my ($type, $offset, $vaddr, $physaddr, $size, $memsz, $flags, $align) =
         unpack "N*", substr($phents, 0x20 * $phi, 0x20);

      $type != 2
         or die "dynamic loading is not supported";

      next unless $type == 1;
      next unless $size;

      die "seek: $!" if !seek($file, $offset + $base_ofs, 0);
      my $data;
      $size = ($size + 3) & ~3;
      while ($size > 0) {
         my $toread = $size < 65536 ? $size : 65536;
         die "read: $!" if $toread != (read($file, $data, $toread) or 0);
         memset $vaddr, $data;
         $vaddr += $toread; $size -= $toread;
      }
   }

   cpu_reset $entry;

   {
      my $str = STACK + 65536;
      my $ptr = STACK;

      my $add_int = sub {
         memset $ptr, pack "N", $_[0];
         $ptr += 4;
      };

      my $add_str = sub {
         $add_int->($str);
         memset $str, "$_[0]\x00";
         $str += 1 + length $_[0];
      };

      $add_int->(scalar @$argv);
      for (@$argv) { $add_str->($_) }
      $add_int->(0);

      for (@$envv) { $add_str->($_) }
      $add_int->(0);

      # auxv
      for (@$auxv) { $add_int->($_->[0]), $add_int->($_->[1]) }

      $add_int->(0);
      $add_int->(0);
   }
}

if (0) {
   mips_exec
      "/tmp/dash-mipsel",
      ["./run", @ARGV],
#   ["sh", "-c", "for d in 0 1 2 3 4 5 6 7 8 9; do for a in 0 1 2 3 4 5 6 7 8 9; do for b in 0 1 2 3 4 5 6 7 8 9; do for c in 0 1 2 3 4 5 6 7 8 9; do :;done;done;done;done"],
      [map "$_=$ENV{$_}", keys %ENV];
} else {

   my $file;
   if (defined(fileno(DATA))) {
      die "binmode: $!" if !binmode(DATA);
      $file = \*DATA;
      unshift @ARGV, $0;
   } else {
      $file = $ARGV[0];
   }

   # !! TODO(pts): Fix bash.run being unable to find the current directory in
   # Perl 5.004 in %ENV = () here:
   # shell-init: error retrieving current directory: getcwd: cannot access parent directories: Function not implemented
   # sh_makepath: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
   %ENV = () if DETSYS;
   mips_exec $file, \@ARGV, [map "$_=$ENV{$_}", keys %ENV];
}

$::t0 = Time::HiRes::time;
$::n = 0;
cpu_run();
